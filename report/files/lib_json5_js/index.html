<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>lib/json5.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">56.75</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">712</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">93.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">4.64</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">define([], function () {
	// json5.js
	// Modern JSON. See README.md for details.
	//
	// This file is based directly off of Douglas Crockford&#039;s json_parse.js:
	// https://github.com/douglascrockford/JSON-js/blob/master/json_parse.js

	var JSON5 = (typeof exports === &#039;object&#039; ? exports : {});

	JSON5.parse = (function () {
		&quot;use strict&quot;;

		// This is a function that can parse a JSON5 text, producing a JavaScript
		// data structure. It is a simple, recursive descent parser. It does not use
		// eval or regular expressions, so it can be used as a model for implementing
		// a JSON5 parser in other languages.

		// We are defining the function inside of another function to avoid creating
		// global variables.

		var at,     // The index of the current character
        ch,     // The current character
        escapee = {
        	&quot;&#039;&quot;: &quot;&#039;&quot;,
        	&#039;&quot;&#039;: &#039;&quot;&#039;,
        	&#039;\\&#039;: &#039;\\&#039;,
        	&#039;/&#039;: &#039;/&#039;,
        	&#039;\n&#039;: &#039;&#039;,       // Replace escaped newlines in strings w/ empty string
        	b: &#039;\b&#039;,
        	f: &#039;\f&#039;,
        	n: &#039;\n&#039;,
        	r: &#039;\r&#039;,
        	t: &#039;\t&#039;
        },
        text,

        error = function (m) {

        	// Call error when something is wrong.

        	var error = new SyntaxError();
        	error.message = m;
        	error.at = at;
        	error.text = text;
        	throw error;
        },

        next = function (c) {

        	// If a c parameter is provided, verify that it matches the current character.

        	if (c &amp;&amp; c !== ch) {
        		error(&quot;Expected &#039;&quot; + c + &quot;&#039; instead of &#039;&quot; + ch + &quot;&#039;&quot;);
        	}

        	// Get the next character. When there are no more characters,
        	// return the empty string.

        	ch = text.charAt(at);
        	at += 1;
        	return ch;
        },

        identifier = function () {

        	// Parse an identifier. Normally, reserved words are disallowed here, but we
        	// only use this for unquoted object keys, where reserved words are allowed,
        	// so we don&#039;t check for those here. References:
        	// - http://es5.github.com/#x7.6
        	// - https://developer.mozilla.org/en/Core_JavaScript_1.5_Guide/Core_Language_Features#Variables
        	// - http://docstore.mik.ua/orelly/webprog/jscript/ch02_07.htm
        	// TODO Identifiers can have Unicode &quot;letters&quot; in them; add support for those.

        	var key = ch;

        	// Identifiers must start with a letter, _ or $.
        	if ((ch !== &#039;_&#039; &amp;&amp; ch !== &#039;$&#039;) &amp;&amp;
									(ch &lt; &#039;a&#039; || ch &gt; &#039;z&#039;) &amp;&amp;
									(ch &lt; &#039;A&#039; || ch &gt; &#039;Z&#039;)) {
        		error(&quot;Bad identifier&quot;);
        	}

        	// Subsequent characters can contain digits.
        	while (next() &amp;&amp; (
									ch === &#039;_&#039; || ch === &#039;$&#039; ||
									(ch &gt;= &#039;a&#039; &amp;&amp; ch &lt;= &#039;z&#039;) ||
									(ch &gt;= &#039;A&#039; &amp;&amp; ch &lt;= &#039;Z&#039;) ||
									(ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;))) {
        		key += ch;
        	}

        	return key;
        },

        number = function () {

        	// Parse a number value.

        	var number,
							sign = &#039;&#039;,
							string = &#039;&#039;,
							base = 10;

        	if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
        		sign = string = ch;
        		next(ch);
        	}

        	// support for Infinity (could tweak to allow other words):
        	if (ch === &#039;I&#039;) {
        		number = word();
        		if (typeof number !== &#039;number&#039; || isNaN(number)) {
        			error(&#039;Unexpected word for number&#039;);
        		}
        		return (sign === &#039;-&#039;) ? -number : number;
        	}

        	// support for NaN
        	if (ch === &#039;N&#039;) {
        		number = word();
        		if (!isNaN(number)) {
        			error(&#039;expected word to be NaN&#039;);
        		}
        		// ignore sign as -NaN also is NaN
        		return number;
        	}

        	if (ch === &#039;0&#039;) {
        		string += ch;
        		next();
        		if (ch === &#039;x&#039; || ch === &#039;X&#039;) {
        			string += ch;
        			next();
        			base = 16;
        		} else if (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
        			error(&#039;Octal literal&#039;);
        		}
        	}

        	// https://github.com/aseemk/json5/issues/36
        	if (base === 16 &amp;&amp; sign) {
        		error(&#039;Signed hexadecimal literal&#039;);
        	}

        	switch (base) {
        		case 10:
        			while (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
        				string += ch;
        				next();
        			}
        			if (ch === &#039;.&#039;) {
        				string += &#039;.&#039;;
        				while (next() &amp;&amp; ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
        					string += ch;
        				}
        			}
        			if (ch === &#039;e&#039; || ch === &#039;E&#039;) {
        				string += ch;
        				next();
        				if (ch === &#039;-&#039; || ch === &#039;+&#039;) {
        					string += ch;
        					next();
        				}
        				while (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039;) {
        					string += ch;
        					next();
        				}
        			}
        			break;
        		case 16:
        			while (ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039; || ch &gt;= &#039;A&#039; &amp;&amp; ch &lt;= &#039;F&#039; || ch &gt;= &#039;a&#039; &amp;&amp; ch &lt;= &#039;f&#039;) {
        				string += ch;
        				next();
        			}
        			break;
        	}
        	number = +string;
        	if (!isFinite(number)) {
        		error(&quot;Bad number&quot;);
        	} else {
        		return number;
        	}
        },

        string = function () {

        	// Parse a string value.

        	var hex,
							i,
							string = &#039;&#039;,
							delim,      // double quote or single quote
							uffff;

        	// When parsing for string values, we must look for &#039; or &quot; and \ characters.

        	if (ch === &#039;&quot;&#039; || ch === &quot;&#039;&quot;) {
        		delim = ch;
        		while (next()) {
        			if (ch === delim) {
        				next();
        				return string;
        			} else if (ch === &#039;\\&#039;) {
        				next();
        				if (ch === &#039;u&#039;) {
        					uffff = 0;
        					for (i = 0; i &lt; 4; i += 1) {
        						hex = parseInt(next(), 16);
        						if (!isFinite(hex)) {
        							break;
        						}
        						uffff = uffff * 16 + hex;
        					}
        					string += String.fromCharCode(uffff);
        				} else if (typeof escapee[ch] === &#039;string&#039;) {
        					string += escapee[ch];
        				} else {
        					break;
        				}
        			} else if (ch === &#039;\n&#039;) {
        				// unescaped newlines are invalid; see:
        				// https://github.com/aseemk/json5/issues/24
        				// TODO this feels special-cased; are there other
        				// invalid unescaped chars?
        				break;
        			} else {
        				string += ch;
        			}
        		}
        	}
        	error(&quot;Bad string&quot;);
        },

        inlineComment = function () {

        	// Skip an inline comment, assuming this is one. The current character should
        	// be the second / character in the // pair that begins this inline comment.
        	// To finish the inline comment, we look for a newline or the end of the text.

        	if (ch !== &#039;/&#039;) {
        		error(&quot;Not an inline comment&quot;);
        	}

        	do {
        		next();
        		if (ch === &#039;\n&#039;) {
        			next(&#039;\n&#039;);
        			return;
        		}
        	} while (ch);
        },

        blockComment = function () {

        	// Skip a block comment, assuming this is one. The current character should be
        	// the * character in the /* pair that begins this block comment.
        	// To finish the block comment, we look for an ending */ pair of characters,
        	// but we also watch for the end of text before the comment is terminated.

        	if (ch !== &#039;*&#039;) {
        		error(&quot;Not a block comment&quot;);
        	}

        	do {
        		next();
        		while (ch === &#039;*&#039;) {
        			next(&#039;*&#039;);
        			if (ch === &#039;/&#039;) {
        				next(&#039;/&#039;);
        				return;
        			}
        		}
        	} while (ch);

        	error(&quot;Unterminated block comment&quot;);
        },

        comment = function () {

        	// Skip a comment, whether inline or block-level, assuming this is one.
        	// Comments always begin with a / character.

        	if (ch !== &#039;/&#039;) {
        		error(&quot;Not a comment&quot;);
        	}

        	next(&#039;/&#039;);

        	if (ch === &#039;/&#039;) {
        		inlineComment();
        	} else if (ch === &#039;*&#039;) {
        		blockComment();
        	} else {
        		error(&quot;Unrecognized comment&quot;);
        	}
        },

        white = function () {

        	// Skip whitespace and comments.
        	// Note that we&#039;re detecting comments by only a single / character.
        	// This works since regular expressions are not valid JSON(5), but this will
        	// break if there are other valid values that begin with a / character!

        	while (ch) {
        		if (ch === &#039;/&#039;) {
        			comment();
        		} else if (ch &lt;= &#039; &#039;) {
        			next();
        		} else {
        			return;
        		}
        	}
        },

        word = function () {

        	// true, false, or null.

        	switch (ch) {
        		case &#039;t&#039;:
        			next(&#039;t&#039;);
        			next(&#039;r&#039;);
        			next(&#039;u&#039;);
        			next(&#039;e&#039;);
        			return true;
        		case &#039;f&#039;:
        			next(&#039;f&#039;);
        			next(&#039;a&#039;);
        			next(&#039;l&#039;);
        			next(&#039;s&#039;);
        			next(&#039;e&#039;);
        			return false;
        		case &#039;n&#039;:
        			next(&#039;n&#039;);
        			next(&#039;u&#039;);
        			next(&#039;l&#039;);
        			next(&#039;l&#039;);
        			return null;
        		case &#039;I&#039;:
        			next(&#039;I&#039;);
        			next(&#039;n&#039;);
        			next(&#039;f&#039;);
        			next(&#039;i&#039;);
        			next(&#039;n&#039;);
        			next(&#039;i&#039;);
        			next(&#039;t&#039;);
        			next(&#039;y&#039;);
        			return Infinity;
        		case &#039;N&#039;:
        			next(&#039;N&#039;);
        			next(&#039;a&#039;);
        			next(&#039;N&#039;);
        			return NaN;
        	}
        	error(&quot;Unexpected &#039;&quot; + ch + &quot;&#039;&quot;);
        },

        value,  // Place holder for the value function.

        array = function () {

        	// Parse an array value.

        	var array = [];

        	if (ch === &#039;[&#039;) {
        		next(&#039;[&#039;);
        		white();
        		while (ch) {
        			if (ch === &#039;]&#039;) {
        				next(&#039;]&#039;);
        				return array;   // Potentially empty array
        			}
        			// ES5 allows omitting elements in arrays, e.g. [,] and
        			// [,null]. We don&#039;t allow this in JSON5.
        			if (ch === &#039;,&#039;) {
        				error(&quot;Missing array element&quot;);
        			} else {
        				array.push(value());
        			}
        			white();
        			// If there&#039;s no comma after this value, this needs to
        			// be the end of the array.
        			if (ch !== &#039;,&#039;) {
        				next(&#039;]&#039;);
        				return array;
        			}
        			next(&#039;,&#039;);
        			white();
        		}
        	}
        	error(&quot;Bad array&quot;);
        },

        object = function () {

        	// Parse an object value.

        	var key,
							object = {};

        	if (ch === &#039;{&#039;) {
        		next(&#039;{&#039;);
        		white();
        		while (ch) {
        			if (ch === &#039;}&#039;) {
        				next(&#039;}&#039;);
        				return object;   // Potentially empty object
        			}

        			// Keys can be unquoted. If they are, they need to be
        			// valid JS identifiers.
        			if (ch === &#039;&quot;&#039; || ch === &quot;&#039;&quot;) {
        				key = string();
        			} else {
        				key = identifier();
        			}

        			white();
        			next(&#039;:&#039;);
        			if (Object.hasOwnProperty.call(object, key)) {
        				error(&#039;Duplicate key &quot;&#039; + key + &#039;&quot;&#039;);
        			}
        			object[key] = value();
        			white();
        			// If there&#039;s no comma after this pair, this needs to be
        			// the end of the object.
        			if (ch !== &#039;,&#039;) {
        				next(&#039;}&#039;);
        				return object;
        			}
        			next(&#039;,&#039;);
        			white();
        		}
        	}
        	error(&quot;Bad object&quot;);
        };

		value = function () {

			// Parse a JSON value. It could be an object, an array, a string, a number,
			// or a word.

			white();
			switch (ch) {
				case &#039;{&#039;:
					return object();
				case &#039;[&#039;:
					return array();
				case &#039;&quot;&#039;:
				case &quot;&#039;&quot;:
					return string();
				case &#039;-&#039;:
				case &#039;+&#039;:
				case &#039;.&#039;:
					return number();
				default:
					return ch &gt;= &#039;0&#039; &amp;&amp; ch &lt;= &#039;9&#039; ? number() : word();
			}
		};

		// Return the json_parse function. It will have access to all of the above
		// functions and variables.

		return function (source, reviver) {
			var result;

			text = source;
			at = 0;
			ch = &#039; &#039;;
			result = value();
			white();
			if (ch) {
				error(&quot;Syntax error&quot;);
			}

			// If there is a reviver function, we recursively walk the new structure,
			// passing each name/value pair to the reviver function for possible
			// transformation, starting with a temporary root object that holds the result
			// in an empty key. If there is not a reviver function, we simply return the
			// result.

			return typeof reviver === &#039;function&#039; ? (function walk(holder, key) {
				var k, v, value = holder[key];
				if (value &amp;&amp; typeof value === &#039;object&#039;) {
					for (k in value) {
						if (Object.prototype.hasOwnProperty.call(value, k)) {
							v = walk(value, k);
							if (v !== undefined) {
								value[k] = v;
							} else {
								delete value[k];
							}
						}
					}
				}
				return reviver.call(holder, key, value);
			}({ &#039;&#039;: result }, &#039;&#039;)) : result;
		};
	}());

	// JSON5 stringify will not quote keys where appropriate
	JSON5.stringify = function (obj, replacer, space) {

		if (replacer) {
			throw new Error(&#039;JSON5 does not support the replacer parameter. Use JSON instead.&#039;);
		}

		function isWordChar(char) {
			return (char &gt;= &#039;a&#039; &amp;&amp; char &lt;= &#039;z&#039;) ||
							(char &gt;= &#039;A&#039; &amp;&amp; char &lt;= &#039;Z&#039;) ||
							(char &gt;= &#039;0&#039; &amp;&amp; char &lt;= &#039;9&#039;) ||
							char === &#039;_&#039; || char === &#039;$&#039;;
		}

		function isWordStart(char) {
			return (char &gt;= &#039;a&#039; &amp;&amp; char &lt;= &#039;z&#039;) ||
							(char &gt;= &#039;A&#039; &amp;&amp; char &lt;= &#039;Z&#039;) ||
							char === &#039;_&#039; || char === &#039;$&#039;;
		}

		function isWord(key) {
			if (typeof key !== &#039;string&#039;) {
				return false;
			}
			if (!isWordStart(key[0])) {
				return false;
			}
			var i = 1, length = key.length;
			while (i &lt; length) {
				if (!isWordChar(key[i])) {
					return false;
				}
				i++;
			}
			return true;
		}

		// export for use in tests
		JSON5.isWord = isWord;

		// polyfills
		function isArray(obj) {
			if (Array.isArray) {
				return Array.isArray(obj);
			} else {
				return Object.prototype.toString.call(obj) === &#039;[object Array]&#039;;
			}
		}

		function isDate(obj) {
			return Object.prototype.toString.call(obj) === &#039;[object Date]&#039;;
		}

		isNaN = isNaN || function (val) {
			return typeof val === &#039;number&#039; &amp;&amp; val !== val;
		};

		var objStack = [];
		function checkForCircular(obj) {
			for (var i = 0; i &lt; objStack.length; i++) {
				if (objStack[i] === obj) {
					throw new TypeError(&quot;Converting circular structure to JSON&quot;);
				}
			}
		}

		function makeIndent(str, num, noNewLine) {
			if (!str) {
				return &quot;&quot;;
			}
			// indentation no more than 10 chars
			if (str.length &gt; 10) {
				str = str.substring(0, 10);
			}

			var indent = noNewLine ? &quot;&quot; : &quot;\n&quot;;
			for (var i = 0; i &lt; num; i++) {
				indent += str;
			}

			return indent;
		}

		var indentStr;
		if (space) {
			if (typeof space === &quot;string&quot;) {
				indentStr = space;
			} else if (typeof space === &quot;number&quot; &amp;&amp; space &gt;= 0) {
				indentStr = makeIndent(&quot; &quot;, space, true);
			} else {
				// ignore space parameter
			}
		}

		// Copied from Crokford&#039;s implementation of JSON
		// See https://github.com/douglascrockford/JSON-js/blob/e39db4b7e6249f04a195e7dd0840e610cc9e941e/json2.js#L195
		// Begin
		var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\&quot;\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
                meta = { // table of character substitutions
                	&#039;\b&#039;: &#039;\\b&#039;,
                	&#039;\t&#039;: &#039;\\t&#039;,
                	&#039;\n&#039;: &#039;\\n&#039;,
                	&#039;\f&#039;: &#039;\\f&#039;,
                	&#039;\r&#039;: &#039;\\r&#039;,
                	&#039;&quot;&#039;: &#039;\\&quot;&#039;,
                	&#039;\\&#039;: &#039;\\\\&#039;
                };
		function escapeString(string) {

			// If the string contains no control characters, no quote characters, and no
			// backslash characters, then we can safely slap some quotes around it.
			// Otherwise we must also replace the offending characters with safe escape
			// sequences.
			escapable.lastIndex = 0;
			return escapable.test(string) ? &#039;&quot;&#039; + string.replace(escapable, function (a) {
				var c = meta[a];
				return typeof c === &#039;string&#039; ?
					c :
						&#039;\\u&#039; + (&#039;0000&#039; + a.charCodeAt(0).toString(16)).slice(-4);
			}) + &#039;&quot;&#039; : &#039;&quot;&#039; + string + &#039;&quot;&#039;;
		}
		// End

		function internalStringify(obj_part) {
			var buffer, res;
			if (obj_part &amp;&amp; !isDate(obj_part)) {
				// unbox objects
				// don&#039;t unbox dates, since will turn it into number
				obj_part = obj_part.valueOf();
			}
			switch (typeof obj_part) {
				case &quot;boolean&quot;:
					return obj_part.toString();

				case &quot;number&quot;:
					if (isNaN(obj_part) || !isFinite(obj_part)) {
						return &quot;null&quot;;
					}
					return obj_part.toString();

				case &quot;string&quot;:
					return escapeString(obj_part.toString());

				case &quot;object&quot;:
					if (obj_part === null) {
						return &quot;null&quot;;
					} else if (isDate(obj_part)) {
						return escapeString(obj_part.toJSON());
					} else if (isArray(obj_part)) {
						checkForCircular(obj_part);
						buffer = &quot;[&quot;;
						objStack.push(obj_part);

						for (var i = 0; i &lt; obj_part.length; i++) {
							res = internalStringify(obj_part[i]);
							buffer += makeIndent(indentStr, objStack.length);
							if (res === null || typeof res === &quot;undefined&quot;) {
								buffer += &quot;null&quot;;
							} else {
								buffer += res;
							}
							if (i &lt; obj_part.length - 1) {
								buffer += &quot;,&quot;;
							} else if (indentStr) {
								buffer += &quot;\n&quot;;
							}
						}
						objStack.pop();
						buffer += makeIndent(indentStr, objStack.length, true) + &quot;]&quot;;
					} else {
						checkForCircular(obj_part);
						buffer = &quot;{&quot;;
						var nonEmpty = false;
						objStack.push(obj_part);
						for (var prop in obj_part) {
							if (obj_part.hasOwnProperty(prop)) {
								var value = internalStringify(obj_part[prop]);
								if (typeof value !== &quot;undefined&quot; &amp;&amp; value !== null) {
									buffer += makeIndent(indentStr, objStack.length);
									nonEmpty = true;
									var key = isWord(prop) ? prop : escapeString(prop);
									buffer += key + &quot;:&quot; + (indentStr ? &#039; &#039; : &#039;&#039;) + value + &quot;,&quot;;
								}
							}
						}
						objStack.pop();
						if (nonEmpty) {
							buffer = buffer.substring(0, buffer.length - 1) + makeIndent(indentStr, objStack.length) + &quot;}&quot;;
						} else {
							buffer = &#039;{}&#039;;
						}
					}
					return buffer;
				default:
					// functions and undefined should be ignored
					return undefined;
			}
		}

		// special case...when undefined is used inside of
		// a compound object/array, return null.
		// but when top-level, return undefined
		if (obj === undefined) {
			return undefined;
		}
		return internalStringify(obj, replacer, space);
	};
	return JSON5;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
